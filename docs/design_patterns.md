---
hide:
  - navigation
---
# Design Patterns
Design patterns are typically categorized into three main groups based on their purpose:

1. Creational Patterns
Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. 
Eg: Singleton, Factory Method, Abstract Factory, Builder, and Prototype patterns.

2. Structural Patterns
These patterns focus on class and object composition. 
Eg: Adapter, Decorator, Proxy, Facade, Bridge, Composite, and Flyweight patterns.

3. Behavioral Patterns
These patterns are concerned in defining how objects interact and communicate with each other. 
Eg: Observer, Strategy, Command, Chain of Responsibility, Iterator, State, Template Method, Visitor, Memento, and Mediator patterns.

## Creational Patterns
### Singleton
Ensures that a class has only one instance and provides a global point of access to that instance.

### Factory
Defines an interface for creating an object, but allows subclasses to alter the type of objects that will be created.

### Builder
Used when there are a sequence of steps that needs to be called while creating a class object, like when configuring a sequence of optional parameters.

### Prototype
Creates new objects by copying an existing object, known as the prototype, during runtime.

## Structural Patterns
### Adapter
Allows incompatible interfaces to work together by converting the interface of a class into another interface that a client expects.

### Decorator
Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.

### Proxy
Provides a surrogate or placeholder for another object to control access to it.

### Composite
TBD

## Behavioral Patterns
### Observer
when one object changes state, all its dependents are notified and updated automatically.

### Strategy

### Command


### Chain of Responsibility

### Iterator